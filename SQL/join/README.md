# wb-tech-school-hw1/SQL/join

Задания выполнялись с использованием PostgreSQL.

## Часть 1. Задание 1.
В условии сказано найти “клиента”, подходящего под условие. Найдем одного клиента.
После `JOIN` двух таблиц для получения имени клиента выполняется сортировка по убыванию времени ожидания, и берется одна запись. Так мы получим, одного клиента с самым долгим временем ожидания между заказом и доставкой. Замечу, что вычитая timestamp’ы мы получаем тип данных `interval`, который поддерживает сравнение (соответственно можем выполнить сортировку по этому столбцу).

В наших данных есть такой столбец `order_status`, где сказано утвержден / завершен заказ `Approved` или отменен `Cancel`. Но у нас отсутствуют вводные на этот счет. В ходе обсуждения этого момента в беседе было решено считать наличие даты доставки маркером того, что заказ был действительно доставлен, после покупатель мог его забрать `Approved` или отказаться `Cancel`. Соответственно, раз мы говорим о наличии даты доставки надо учесть случай, когда ее не будет - `NULL` (например, пользователь сделал заказ по ошибке и сразу его отменил). Этот `NULL` (который приведет к тому, что в результирующей таблице нашего запроса в столбце `waiting_time` появится `NULL`) может помешать нашей сортировке (при сортировке по убыванию NULL'ы находятся в начале) и нахождению самого долгого времени ожидания, поэтому при сортировке укажем `NULLS LAST`. 

Также необходимо отметить, что в наших таблицах всего по 100 записей, поэтому я сразу делаю join этих таблиц. Если же нам бы понадобилось работать с большими объемами данных, то можно было бы сначала найти клиента с наибольшим временем ожидания, а лишь потом выполнить `JOIN` (соответственно это + еще один запрос). Дабы не мудрить для наших небольших таблиц и не делать ещё каких-либо запросов, я оставляю решение с джойном сразу.

В задании сказано "клиента", но если, к примеру, мы хотим как-нибудь сделать клиентам, которые долго ждут, доставку побыстрее, то какой толк от всего одного клиента, тогда хотелось бы посмотреть на всех таких клиентов. Для этого я оставил в решении закомментированный запрос.

## Часть 1. Задание 2.
Я делаю одну группировку, в которой вычисляю искомые величины: id клиента, среднее время между заказом и доставкой, общую сумму заказа. 

Во втором select я указываю, что нас интересуют клиенты с наибольшим количеством заказов. Также для получения имени клиента я выполню `JOIN` именно в этом `SELECT` (так мы будем джойнить не всю таблицу `Orders`, а агрегаты, полученные по группам из этой таблицы).

## Часть 1. Задание 3.
“Найти клиентов, у которых были заказы, доставленные с задержкой более чем на 5 дней, и клиентов, у которых были заказы, которые были отменены.”. Данное предложение я интерпретирую как клиентов, подходящих под одно из двух условий.

“Для каждого клиента вывести имя, количество доставок с задержкой, количество отмененных заказов и их общую сумму. ”. Здесь “их” с точки зрения русского языка относится к “отмененным заказам”, так что будем искать общую сумму отмененных заказов.

Если же у клиента количество отмененных заказов 0, то у него нету общей суммы отмененных заказов, в таком случае разумно указывать такую общую сумму, как `NULL`.

Есть возможность решить это задание без всяких табличных выражений, но мы делаем для людей, поэтому вот объяснение читаемой / понимаемой версии.

В табличном выражении `get_criteria` для каждого клиента определяется, была ли доставка более 5 дней, была ли отмена. Если же отмена была, то для данного клиента выводится сумма заказа, иначе `NULL` – поле `cancel_amount`.

В запросе сначала выполняется `JOIN` табличного выражения `get_criteria` с таблицей Customers для получения имен клиентов. Имея подсчитанные в табличном выражении критерии для фильтрации, делается фильтрация where - берутся пользователи, подходящие под одно из двух условий. Выполняется группировка по id клиента и по имени (не влияет на группировку, но имя нужно для вывода). 

Заметим, что наши `is_delay` и `is_cancel` из `get_critetia` имеют тип данных `boolean`; count для конкретного столбца считает количество не NULL-значений в столбце, нам же интересно количество true в этих столбцах. Преобразуем эти поля к целочисленному типу данных и выполним суммирование.

`SUM` при подсчете игнорирует `NULL`. Если же суммируются только NULL’ы, то `SUM` вернет `NULL`. Делая `SUM(cancel_amount)`, мы как раз хотели (в начале задания 3 я это прописал), чтобы для клиентов без отмененных заказов общая сумма заказов была `NULL`. 

`COALESCE(SUM(is_delay::INTEGER), 0)` – здесь я хочу получить количество задержек. Но мы помним, что в задании 1 мы говорили о наличии / отсутствием даты доставки. Учтем случай, когда для  клиента все даты доставки будут `NULL` (например, клиент понаделал заказы и отменил их все). Тогда в качестве `is_delay` в сумме будут только NULL'ы, и суммирование даст нам `NULL`. То есть в столбце `delay_num` будет `NULL`. Но в этом столбце `delay_num` и в столбце `cancel_num` для наших данных, например, мы видим 0, и дабы следовать единообразию сделаем `delay_num` тоже 0 для описанного (тем более задержек то действительно не было). Для этого я использую `COALESCE`, который возвращает первый не-NULL из списка аргументов, т.е. либо число задержек, либо если оно `NULL`, то `0`.

Для каждой группы выводим имя клиента `name`, количество задержек `delay_num`, количество отмен `cancel_num` и считаем общую сумму отмененных заказов `total_canceled_amount`, как `sum(cancel_amount)` – в этой общей сумме выполняется суммирование сумм заказов (для отмененных заказов) и NULL’ов (для остальных). 

В конце выполняем нужную сортировку, NULL’ы для удобства просмотра результата выводим в конце с помощью указания `NULLS LAST`.

## Часть 2. 
В условии идет речь именно об одном SQL-запросе (у меня это файл **part 2.sql**), который выполнит все пункты, так и сделаем в конце. На всякий случай я добавил решение каждого пункта по отдельности в папку [part 2 items](https://github.com/Daniel1871/wb-tech-school-hw1/tree/main/SQL/join/part%202%20items), ведь итоговый запрос, по сути, просто объединяет данные решения. 

Дабы оставить код единственного нашего SQL-запроса понятным и читаемым я делаю табличные выражения для каждого задания `task1`, `task2`, `task3`.

Также я даю более понятные названия для результирующих столбцов табличных выражений, чтобы все было понятно в общей результирующей таблице:

- `category` – категория продукта
- `total_sum` – общая сумма продаж для каждой категории
- `category_max` – категория продукта с наибольшей общей суммой продаж
- `max_total_sum` – наибольшая сумма продаж категории `category_max`
- `product_name_max_sum` – продукт с максимальной суммой продаж в категории
- `max_product_sum` – максимальная сумма продаж продукта `product_name_max_sum` в категории

### Пункт 1.
Здесь надо выполнять `RIGHT JOIN` таблицы `Orders` с таблицей `Products`, т.к. в `Products` могут быть категории таких продуктов, которых нет в таблице `Orders`. Тогда `SUM(order_ammount)` для всех NULL’ов вернул бы нам `NULL`. Для таких случаев будем указывать сумму, равной `0` (товары из категории, пока не заказывались, значит, общая сумма продаж равна `0`). Реализуется это благодаря использованию `COALESCE`, который вернет первый не-NULL из списка аргументов, т.е. либо сумму продаж, либо если она `NULL`, то `0`.

В наших данных, как оказалось, вышеописанных категорий нету, но никто не исключает возможности того, что завтра нам могут принести другие данные. Поэтому решаем задачу правильно и используем `RIGHT JOIN`.

P.S. Рассуждения по поводу NULL’ов и правого джойна, а также все пункты я проверил на измененных данных с наличием вышеописанных категорий.

### Пункт 2.
Здесь дописываем первый запрос, указывая сортировку по убыванию общей суммы продаж и выбирая одну запись. В `task2` мы имеем возможность использовать данные из `task1` (взять максимум по сумме продаж – искать максимум по 2-му столбцу `task1`), так что воспользуемся для этого `task1`. Если же интересно решение `task2` без использования `task1`, то оно также как и решение каждого из других пунктов лежит в папке [part 2 items](https://github.com/Daniel1871/wb-tech-school-hw1/tree/main/SQL/join/part%202%20items) (по сути, там ничего нового, просто использование `task1` позволяет нам не дублировать код).

### Пункт 3.
Аналогично будем использовать `RIGHT JOIN` для правильности запроса.

Сразу определимся, что для категорий продуктов, которых нет в `Orders`, мы укажем искомый продукт с максимальной суммой продаж, как `NULL` (ведь ничего не продавалось, значит, и нету такого продукта), а максимальной суммой продажи этого продукта сделаем также `NULL` (нету искомого продукта, значит, и нету у него максимальной суммы продаж).

Перейдем к решению. Если оставить `COALESCE`, как в прошлых пунктах, то получится следующее: в категориях, продукты которых не описаны в `Orders`, у всех товаров сумма продаж будет `0`, значит, максимальная сумма продаж тоже `0`, и все товары будут являться товарами с максимальной суммой продаж категориях – звучит не очень (можем при выводе получить много записей, хотя в таких категориях даже заказов не было, как и товаров с максимальной суммой продаж). Убираем `COALESCE`.

Чтобы искать максимум суммы продаж, сначала бы надо определить суммы продаж. Для этого табличное выражение `get_groups` выполняет группировку по категории `product_category` и по продукту `product_id`, также по `product_name` для получения имени (но это не влияет на результат группировки). По каждой группе я получаю сумму продаж определенного продукта в определенной категории. 

Подзапрос `get_maxes` находит для каждой категории максимальную сумму продаж продуктов среди имеющихся сумм продаж. Для этого выполняется группировка по `product_category` в табличном выражении `get_groups` и считается максимум. 

После этого я делаю запрос, в котором хочу соединить `get_groups` с подзапросом `get_maxes` (по сути, для каждой группы (категория, продукт) мы хотим указать, какой максимум суммы продаж для категории) по условию равенства категорий и по условию сумма продаж – есть максимальная сумма продаж для данной категории. Но мы понимаем что в get_maxes для категорий, продукты которых не описаны в `Orders` (те самые категории, о которых я в начале долго рассказывал), в качестве максимума стоит `NULL` (потому что брался максимум из NULL’ов – сумм продаж продуктов, которые не заказывались), соответственно, такие категории не дадут истину в условии джойна. 

Как же их включить в результат, ведь в задании сказано "для каждой категории"? Использовать `RIGHT JOIN` табличного выражения `get_groups` с подзапросом `get_maxes` - так мы включим не вошедшие в `INNER JOIN` категории таких продуктов, которых нету в таблице `Orders`. Итого: для этих категорий, продукты которых не заказывались имеем следующее: общая сумма продаж для каждой категории `total_sum` будет `0`, продукт с максимальной суммой продаж в категории `product_name_max_sum` будет `NULL` (ведь продукты не заказывались в этой категории), максимальная сумма продаж продукта в категории `max_product_sum` тоже `NULL`. С точки зрения логики вроде бы звучит здраво (конечно можно `total_sum` указать как `NULL` при желании, но, как мне кажется, по этим категориям могут допустим сделать заказ завтра, а пока по ним не заказывали и имеется общая сумма продаж `0`).

P.S. В условии не сказано, что делать, если найдется несколько продуктов с максимальной суммой продаж. У меня в запросе в таком случае выводятся все такие продукты для категории. Мне кажется это очень даже логично, ведь с точки зрения дальнейшей полезности результата запроса, нам могут быть интересны все такие продукты. Например, раз мы видим, что эти продукты приносят большую выручку нам, мы попробуем увеличить цену, дабы увеличить и прибыль. А если мы не увеличим цену для каких-то продуктов в силу выбора именно 1 в каждой категории, а не всех мы можем недополучить прибыль. Понятно, что увеличение цены может в конечном счете может прибыль нам порезать, но всё равно, чтобы видеть полную картину, хорошо бы иметь все товары, имеющие максимальную сумму продаж в каждой категории.

### Соединение task1, task2 и task3.
В итоге я соединяю task’и следующим образом: `task1` и `task2` декартово (ведь в `task2` всего лишь одна запись), и `INNER JOIN` с `task3` по категории.
