# wb-tech-school-hw1/SQL/join

Задания выполнялись с использованием PostgreSQL.

## Часть 1. Задание 1.
В условии сказано найти “клиента”, подходящего под условие. Найдем одного клиента.
После join двух таблиц для получения имени клиента выполняется сортировка по убыванию времени ожидания, и берется одна запись. Так мы получим, одного клиента с самым долгим временем ожидания между заказом и доставкой. Замечу, что вычитая timestamp’ы мы получаем тип данных `interval`, который поддерживает сравнение (соответственно можем выполнить сортировку по этому столбцу).

В наших данных есть такой столбец order_status, где сказано утвержден / завершен заказ (Approved) или отменен (Cancel). Но у нас отсутствуют вводные на этот счет. В ходе обсуждения этого момента в беседе было решено считать наличие даты доставки маркером того, что заказ был действительно доставлен, после покупатель мог его забрать (Approved) или отказаться (Cancel). Соответственно, раз мы говорим о наличии даты доставки, потенциально может быть случай, когда ее не будет (например, пользователь сделал заказ по ошибке и сразу его отменил). Этот NULL (который приведет к тому, что в результирующей таблице нашего запроса в столбце waiting_time появится NULL) может помешать нашей сортировке (при сортировке по убыванию NULL'ы находятся в начале) и нахождению самого долгого времени ожидания, поэтому при сортировке укажем NULLS LAST. 

Также необходимо отметить, что в наших таблицах всего по 100 записей, поэтому я сразу делаю join этих таблиц. Если же нам бы понадобилось работать с большими объемами данных, то можно было бы сначала найти клиента с наибольшим временем ожидания, а лишь потом выполнить join (соответственно это + еще один запрос). Дабы не мудрить для наших небольших таблиц и не делать ещё каких-либо запросов, я оставляю решение с join’ом сразу.

В задании сказано "клиента", но если, к примеру, мы хотим как-нибудь сделать клиентам, которые долго ждут, доставку побыстрее, то какой толк от всего одного клиента, тогда хотелось бы посмотреть на всех таких клиентов. Для этого я оставил в решении закомментированный запрос.

## Часть 1. Задание 2.
Я делаю одну группировку, в которой вычисляю искомые величины: id клиента, среднее время между заказом и доставкой, общую сумму заказа. 

Во втором select я указываю, что нас интересуют клиенты с наибольшим количеством заказов. Также для получения имени клиента я выполню join именно в этом select (так мы будем join’ить не всю таблицу Orders, а агрегаты, полученные по группам из этой таблицы).

## Часть 1. Задание 3.
“Найти клиентов, у которых были заказы, доставленные с задержкой более чем на 5 дней, и клиентов, у которых были заказы, которые были отменены.”. Данное предложение я интерпретирую как клиентов, подходящих под одно из двух условий.

“Для каждого клиента вывести имя, количество доставок с задержкой, количество отмененных заказов и их общую сумму. ”. Здесь “их” с точки зрения русского языка относится к “отмененным заказам”, так что будем искать общую сумму отмененных заказов.

Если же у клиента количество отмененных заказов, 0 то у него нету общей суммы отмененных заказов, в таком случае разумно указывать такую общую сумму, как NULL.

Есть возможность решить это задание без всяких табличных выражений, но мы делаем для людей, поэтому вот объяснение читаемой / понимаемой версии.

В табличном выражении get_criteria для каждого клиента определяется, была ли доставка более 5 дней, была ли отмена. Если же отмена была, то для данного клиента выводится сумма заказа, иначе NULL – поле cancel_amount.

В запросе сначала выполняется JOIN табличного выражения get_criteria с таблицей Customers для получения имен клиентов. Имея подсчитанные в табличном выражении критерии для фильтрации, делается фильтрация where - берутся пользователи, подходящие под одно из двух условий. Выполняется группировка по id клиента и по имени (не влияет на группировку, но имя нужно для вывода). 

Заметим, что наши is_delay и is_cancel из get_critetia имеют тип данных boolean; count для конкретного столбца считает количество не null значений в столбце, нам же интересно количество true в этих столбцах. Преобразуем эти поля к целочисленному типу данных и выполним суммирование.

SUM при подсчете игнорирует NULL. Если же суммируются только NULL’ы, то sum вернет NULL. Делая SUM(cancel_amount), мы как раз хотели, чтобы для клиентов без отмененных заказов общая сумма заказов была NULL. 

`COALESCE(SUM(is_delay::INTEGER), 0)` здесь я хочу получить количество задержек, но если для клиента в качестве is_delay в сумме будут только NULL'ы (это как раз случай, когда дата доставки NULL), то суммирование даст нам NULL, я же хочу вывести 0, т.к. по сути было 0 задержек. COALESCE вернет первый не-NULL из списка аргументов, т.е. либо число задержек, либо если оно NULL, то 0.

Для каждой группы выводим имя клиента (name), количество задержек(delay_num), количество отмен (cancel_num) и считаем общую сумму отмененных заказов (total_canceled_amount), как sum(cancel_amount) – в этой общей сумме выполняется суммирование сумм заказов (для отмененных заказов) и NULL’ов (для остальных). 

В конце выполняем нужную сортировку, NULL’ы для удобства просмотра результата выводим в конце с помощью указания NULLS LAST.

## Часть 2. 
В условии идет речь именно об одном SQL-запросе, который выполнит все пункты, так и сделаем в конце. На всякий случай я добавил решение каждого пункта по отдельности в папку *part 2 items*, ведь итоговый запрос, по сути, просто объединяет данные решения.

Дабы оставить код единственного нашего SQL-запроса понятным и читаемым я делаю табличные выражения для каждого задания task1, task2, task3.

Также я даю более понятные названия для результирующих столбцов табличных выражений, чтобы все было понятно в общей результирующей таблице:

*category* – категория продукта

*total_sum* – общая сумма продаж для каждой категории

*category_max* – категория продукта с наибольшей общей суммой продаж

*max_total_sum* – наибольшая сумма продаж категории *category_max*

*product_name_max_sum* – продукт с максимальной суммой продаж в категории

*max_product_sum* – максимальная сумма продаж продукта *product_name_max_sum* в категории

### Пункт 1.
Здесь надо выполнять RIGHT JOIN Orders с Products, т.к. в таблице Products могут быть категории таких продуктов, которых нет в таблице Orders. Тогда SUM(order_ammount) для всех NULL’ов вернул бы нам NULL. Для таких случаев будем указывать сумму, равной 0 (товары из категории, пока не заказывались ⇒ общая сумма продаж равна 0). Реализуется это благодаря использованию COALESCE, который вернет первый не-NULL из списка аргументов, т.е. либо сумму продаж, либо если она NULL, то 0.

В наших данных, как оказалось, вышеописанных категорий нету, но никто не исключает возможности того, что завтра нам могут принести другие данные. Поэтому решаем задачу правильно и используем RIGHT JOIN.

P.S. Рассуждения по поводу NULL’ов и RIGHT JOIN’а, а также все пункты я проверил на измененных данных с наличием вышеописанных категорий.

### Пункт 2.
Здесь дописываем первый запрос, указывая сортировку по убыванию общей суммы продаж и выбирая одну запись. В task2 мы имеем возможность использовать данные из task1 (взять максимум по сумме продаж – искать максимум по 2-му столбцу task1), так что воспользуемся для этого task1. Если же интересно решение task2 без использования task1, то оно также как и решение каждого из других пунктов лежит в папке *part 2 items* (по сути, там ничего нового, просто использование task1 позволяет нам не дублировать код).

### Пункт 3.
Аналогично будем использовать RIGHT JOIN для правильности запроса.

Сразу определимся, что для категорий продуктов, которых нет в Orders, мы укажем искомый продукт с максимальной суммой продаж, как NULL (ведь ничего не продавалось, значит, и нету такого продукта), а максимальной суммой продажи этого продукта сделаем также NULL (нету искомого продукта, значит, и нету у него максимальной суммы продаж).

Перейдем к решению. Если оставить COALESCE, как в прошлых пунктах, то получится следующее: в категориях, продукты которых не описаны в Orders, у всех товаров сумма продаж будет 0, значит, максимальная сумма продаж тоже 0, и все товары будут являться товарами с максимальной суммой продаж категориях – звучит не очень (можем при выводе получить много записей, хотя в таких категориях даже заказов не было, как и товаров с максимальной суммой продаж). Убираем COALESCE.

Чтобы искать максимум суммы продаж, сначала бы надо определить суммы продаж. Для этого табличное выражение get_groups выполняет группировку по категории (product_category) и по продукту (product_id), также по product_name для получения имени (но это не влияет на результат группировки). По каждой группе я получаю сумму продаж определенного продукта в определенной категории. 

Подзапрос get_maxes находит для каждой категории максимальную сумму продаж продуктов среди имеющихся сумм продаж. Для этого выполняется группировка по product_category в табличном выражении get_groups и считается максимум. 

После этого я делаю запрос, в котором хочу соединить get_groups с подзапросом get_maxes (по сути, для каждой группы (категория, продукт) мы хотим указать, какой максимум суммы продаж для категории) по условию равенства категорий и по условию сумма продаж – есть максимальная сумма продаж для данной категории. Но мы понимаем что в get_maxes для категорий, продукты которых не описаны в Orders (те самые категории, о которых я в начале долго рассказывал), в качестве максимума стоит NULL (потому что брался максимум из NULL’ов – сумм продаж продуктов, которые не заказывались), соответственно, такие категории не дадут true в условии ON. 

Как же их включить в результат, ведь в задании сказано "для каждой категории"? Использовать RIGHT JOIN get_groups с get_maxes - так мы включим не вошедшие в INNER JOIN категории таких продуктов, которых нету в таблице Orders. Итого: для этих категорий, продукты которых не заказывались имеем следующее: общая сумма продаж для каждой категории (total_sum) будет 0, продукт с максимальной суммой продаж в категории (product_name_max_sum) будет NULL (ведь продукты не заказывались в этой категории), максимальная сумма продаж продукта в категории (max_product_sum) тоже NULL. С точки зрения логики вроде бы звучит здраво (конечно можно total_sum указать как NULL при желании, но, как мне кажется, по этим категориям могут допустим сделать заказ завтра, а пока по ним не заказывали и имеется общая сумма продаж 0).

### Соединение task1, task2 и task3.
В итоге я соединяю task’и следующим образом: task1 и task2 декартово (ведь в task2 всего лишь одна запись), и INNER JOIN с task3 по категории.
