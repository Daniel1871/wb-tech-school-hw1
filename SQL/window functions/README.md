# wb-tech-school-hw1/SQL/window functions

## Часть 1.
Сразу оговорюсь, что в качестве имя сотрудника для данного отдела с самой высокой зарплатой `name_highest_sal` я буду выводить имя и фамилию, ведь как мы знаем, людей с одним именем в этой жизни слишком много.

### Решение без оконных функций.
Табличные выражения `get_maxes` и `get_employees` по сути идентичны аналогичным запросам только что сделанного пункта 3 по джойнам (там было для каждой категории продуктов найти продукт с максимальной суммой продаж, здесь – для каждого отдела найти сотрудника с максимальной зарплатой). 

Табличное выражение `get_maxes` извлекает для каждого отдела `industry` максимальную зарплату `max_salary`. 

Табличное выражение `get_employees` получает имена сотрудников `name_highest_sal` с максимальной зарплатой в каждом отделе через условие в джойне – сравнение зарплаты сотрудника `salary` в отделе`industry` с максимальной зарплатой в отделе `max_salary`. 

В финальном запросе через соединение таблицы `Salary` с табличным выражением `get_employees` по условию равенства отделов мы имеем для каждого сотрудника таблицы искомое поле `name_highest_sal`.

В задании сказано вывести сначала для максимума, потом для минимума – я и сделал 2 SQL-запроса.

Отмечу, что если в каком-то отделе будет несколько сотрудников с max/min зарплатой, то в этом решении и выводятся все такие сотрудники. Данный момент четко не прописан в условии, поэтому, по моему мнению, с точки зрения дальнейшего применения нам могут быть интересны все сотрудники с max/min зарплатой, чтобы например уменьшить / увеличить всем им зарплату, а не кому то одному. Понятно, что чтобы извлечь одного сотрудника можно использовать какой-нибудь LIMIT: 

```sql
WITH get_max_employees (industry, name_highest_sal) AS (
    SELECT
        industry, 
        (SELECT CONCAT(Salary.first_name, ' ', Salary.last_name)
         FROM Salary
         WHERE Salary.industry = s2.industry AND Salary.salary = MAX(s2.salary)
         ORDER BY id desc
         LIMIT 1)
    FROM Salary s2
    GROUP BY industry
)
SELECT first_name, last_name, salary, industry, name_highest_sal
FROM Salary JOIN get_max_employees USING(industry)
ORDER BY industry, salary, id;
```
Но в файлах я оставляю решение, которое дает мне всех сотрудников (раз min/max могут нам дать всех сотрудников, зачем нам от этого отказываться, если эти результаты могут быть полезны для нас).

Также для удобства лицезрения отдела, зарплат в нем (и сотрудников с max/min зарплатой) я буду сортировать результат по `industry`, `salary`, `id` (на случай равных зарплат в отделе), `name_highest_sal` / `name_lowest_sal`(для случая наличия нескольких сотрудников с max/min зарплатой).

### Решение с оконными функциями.
Я решил это задание для сотрудников и с max, и с min зарплатой в одном запросе, дабы попользоваться `FIRST_VALUE` и `LAST_VALUE` и просто-напросто не копировать один и тот же код (тут, что интересно: чтобы найти `name_highest_sal` можно было бы не использовать `LAST_VALUE`, а использовать `FIRST_VALUE` с убывающей сортировкой по зарплате – тогда не придется работать с `ROWS BETWEEN`). 

В `WINDOW w` я разделяю на секции (окна) по отделам `industry`, при этом внутри секции записи упорядочены по возрастанию зарплаты `salary` (также я указал `id`, чтобы в случае одной и той же зарплаты мы понимали, кто именно выведется). Также я указываю, что фреймом будет вся секция через `ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING`. Иначе `LAST_VALUE` будет брать не имя с максимальной зарплатой в секции, а имя с максимальной зарплатой во фрейме (нас такое не устраивает). Терминология здесь используется такая, как и в прикрепленной [статье](https://antonz.ru/window-offset) с теор. материалами.

С помощью указанных оконных функций выбираются имена сотрудников `name_lowest_sal` и `name_highest_sal`с минимальной зарплатой и максимальной зарплатой в отделе соответственно.

Для удобства лицезрения отдела, зарплат в нем (и сотрудников с max/min зарплатой) я буду сортировать результат по `industry`, `salary`, `id` (на случай равных зарплат в отделе).

## Часть 2.
