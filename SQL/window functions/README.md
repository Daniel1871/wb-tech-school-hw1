# wb-tech-school-hw1/SQL/window functions

Задания выполнялись с использованием PostgreSQL.

## Часть 1.
Сразу оговорюсь, что в качестве имя сотрудника для данного отдела с самой высокой зарплатой `name_highest_sal` я буду выводить имя и фамилию, ведь как мы знаем, людей с одним именем в этой жизни слишком много.

### Решение без оконных функций.
Табличные выражения `get_maxes` и `get_employees` по сути идентичны аналогичным запросам только что сделанного пункта 3 по джойнам (там было для каждой категории продуктов найти продукт с максимальной суммой продаж, здесь – для каждого отдела найти сотрудника с максимальной зарплатой). 

Табличное выражение `get_maxes` извлекает для каждого отдела `industry` максимальную зарплату `max_salary`. 

Табличное выражение `get_employees` получает имена сотрудников `name_highest_sal` с максимальной зарплатой в каждом отделе через условие в джойне – сравнение зарплаты сотрудника `salary` в отделе`industry` с максимальной зарплатой в отделе `max_salary`. 

В финальном запросе через соединение таблицы `Salary` с табличным выражением `get_employees` по условию равенства отделов мы имеем для каждого сотрудника таблицы искомое поле `name_highest_sal`.

В задании сказано вывести сначала для максимума, потом для минимума – я и сделал 2 SQL-запроса.

Отмечу, что если в каком-то отделе будет несколько сотрудников с max/min зарплатой, то в этом решении и выводятся все такие сотрудники. Данный момент четко не прописан в условии, поэтому, по моему мнению, с точки зрения дальнейшего применения нам могут быть интересны все сотрудники с max/min зарплатой, чтобы например уменьшить / увеличить всем им зарплату, а не кому то одному. Понятно, что чтобы извлечь одного сотрудника можно использовать какой-нибудь LIMIT: 

```sql
WITH get_max_employees (industry, name_highest_sal) AS (
    SELECT
        industry, 
        (SELECT CONCAT(Salary.first_name, ' ', Salary.last_name)
         FROM Salary
         WHERE Salary.industry = s2.industry AND Salary.salary = MAX(s2.salary)
         ORDER BY id desc
         LIMIT 1)
    FROM Salary s2
    GROUP BY industry
)
SELECT first_name, last_name, salary, industry, name_highest_sal
FROM Salary JOIN get_max_employees USING(industry)
ORDER BY industry, salary, id;
```
Но в файлах я оставляю решение, которое дает мне всех сотрудников (раз min/max могут нам дать всех сотрудников, зачем нам от этого отказываться, если эти результаты могут быть полезны для нас).

Также для удобства лицезрения отдела, зарплат в нем (и сотрудников с max/min зарплатой) я буду сортировать результат по `industry`, `salary`, `id` (на случай равных зарплат в отделе), `name_highest_sal` / `name_lowest_sal`(для случая наличия нескольких сотрудников с max/min зарплатой).

### Решение с оконными функциями.
Я решил это задание для сотрудников и с max, и с min зарплатой в одном запросе, дабы попользоваться `FIRST_VALUE` и `LAST_VALUE` и просто-напросто не копировать один и тот же код (тут, что интересно: чтобы найти `name_highest_sal` можно было бы не использовать `LAST_VALUE`, а использовать `FIRST_VALUE` с убывающей сортировкой по зарплате – тогда не придется работать с `ROWS BETWEEN`), также в моем решении выполняется одна сортировка (в `w`) для вычисления как `FIRST_VALUE`, так и `LAST_VALUE`.

В `WINDOW w` я разделяю на секции (окна) по отделам `industry`, при этом внутри секции записи упорядочены по возрастанию зарплаты `salary` (также я указал `id`, чтобы в случае одной и той же зарплаты мы понимали, кто именно выведется). Я указываю, что фреймом будет вся секция через `ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING`. Иначе `LAST_VALUE` будет брать не имя с максимальной зарплатой в секции, а имя с максимальной зарплатой во фрейме (нас такое не устраивает). Терминология здесь используется такая, как и в рекомендованной [статье](https://antonz.ru/window-offset) с теор. материалами.

С помощью указанных оконных функций выбираются имена сотрудников `name_lowest_sal` и `name_highest_sal`с минимальной зарплатой и максимальной зарплатой в отделе соответственно.

Для удобства лицезрения отдела, зарплат в нем (и сотрудников с max/min зарплатой) я буду сортировать результат по `industry`, `salary`, `id` (на случай равных зарплат в отделе).

## Часть 2. Задание 1.
Данные по продажам за указанную дату отбираются условия `ON` в соединении таблиц. Также раз сказано рассматривать заданную дату, то логично и магазины смотреть за этот период (это к тому, что `LEFT/RIGHT JOIN` делать не будем).

“Укажите для каждого магазина…” – я понимаю как то, что в результате есть магазин (один раз встречается), а для него подсчитаны искомые величины, и так со всеми магазинами. 

В задании не обязали нас использовать оконные функции, тем более что очень удобно здесь воспользоваться группировкой. Я это и делаю.

Выполняется соединение таблицы `SALES` с таблицей `GOODS` по условию для `DATE` и по полю `ID_GOOD` для получения поля `PRICE`, также соединение с `SHOPS` по `SHOPNUMBER` для получения `CITY` и `ADDRESS`. 

Делается группировка по магазинам: по полю `SHOPNUMBER` (также по `CITY` и `ADDRESS`, которые не влияют на группировку, но нужны, чтобы извлечь эти поля из группы). В каждой группе высчитываются искомые `SUM_QTY` и  `SUM_QTY_PRICE`. 

Также СУБД типом по умолчанию для `PRICE` и `QTY` сделала `smallint`. Чтобы не получать ошибку `smallint out of range` при умножении этих величин для получения суммы проданных товаров `SUM_QTY_PRICE` я привожу `PRICE` к типу данных `integer`.

## Часть 2. Задание 2.
Странно написанное словосочетание “Отберите за каждую дату долю от суммарных продаж (в рублях на дату).”, вызывающее вопрос: долю чего? С моей точки зрения, это разумно понимать, как расчет доли продаж каждого города (т.к. не просто же так `CITY` должен быть частью результата) от общих продаж за каждую дату (т.к. сказано “в рублях на дату”).

В табличном выражении `get_groups` выполняется соединение таблицы `SALES` с таблицей `GOODS` по полю `ID_GOOD` и по категории ЧИСТОТА для работы с `DATE_`, также соединение с `SHOPS` по `SHOPNUMBER` для получения `CITY`.

Необходимо получить продажи каждого города по дате. Это делается через группировку по `DATE_` и `CITY` и выполнение `SUM(PRICE::INT * QTY)` – суммируем отдельные продажи по городу для получения продаж каждого города.

Теперь имея продажи каждого города по дате `date_city_sale`, мы можем их просуммировать и получить общие продажи по дате. Это выполняется в финальном запросе с помощью оконной функции `SUM(date_city_sale) OVER (PARTITION BY DATE_)`. Также здесь мы бьем на секции (окна) по датам `DATE_` (ведь нас интересуют общие продажи по дате)

`SUM_SALES_REL` рассчитывается, как продажи каждого города по дате `date_city_sale`, деленные на общие продажи по дате (результат оконной функции). `SUM_SALES_REL` для нашего удобства я округляю до двух знаков после запятой. 

Результаты запроса отсортированы по дате `DATE_` и городу `CITY`, чтобы нам было удобно смотреть на поле `SUM_SALES_REL` для каждого города каждой даты. Для правильного сравнения в сортировке дата приведена к типу данных `DATE`.

Отмечу, что я использую табличное выражение в этом решении для улучшения читаемости кода (хотя несложно всё перенести в один запрос), а также благодаря этому `SUM(PRICE::INT * QTY)` выполняется единожды для каждого города по каждой дате.

## Часть 2. Задание 3.
Табличное выражение `get_rank` даёт нам рейтинг товаров по продажам в штуках в каждом магазине в каждую дату. Это выполняется с помощью оконной функции `RANK`.
Делим на секции по дате `DATE` и магазину `SHOPNUMBER`, а ранг расставляем в соответствии с убывающей сортировкой по количеству проданных товаров `QTY`.

Почему именно `RANK`? По моему мнению, при одном `QTY` надо строкам присваивать один номер в рейтинге (почему мы должны отказываться от какого-то товара с такими же продажами, ведь он нам, также как и все товары с этими продажами, может быть полезен в дальнейшем). Также я использую `RANK`, а не `DENSE_RANK`, дабы если мы 3 товара уже насобирали, то зачем нам еще другие с меньшими продажами.

В финальном запросе просто отбираем те записи из `get_rank`, где `rnk <= 3`. 

Результаты запроса для нашего удобства просмотра отсортированы по дате `DATE_`, магазину `SHOPNUMBER`, а также по рангу `rnk` – логично (если какой-то товар выше в топе, его разумно выводить раньше) и `ID_GOOD` – для однозначности при одном ранге. Для правильного сравнения в сортировке дата приведена к типу данных `DATE`.

## Часть 2. Задание 4.
Выполняется соединение таблицы `SHOPS` с таблицей `SALES` по условию того, что нас интересует именно Санкт-Петербург и по полю `SHOPNUMBER`, также соединение с `GOODS` по `GOOD_ID` для получения `CATEGORY`.

Далее выполняется группировка по `DATE`, `SHOPNUMBER`, `CATEGORY`, ведь согласно условию нам интересны суммы продаж для каждого магазина и категории по определенной дате. 

Для определения искомой предыдущей даты используется оконная функция `LAG`. Данные делятся на секции (окна) по `SHOPNUMBER` и `CATEGORY`, ведь нам надо иметь возможность подтянуть запись с прошлой датой. Поэтому выполняется сортировка по дате внутри секции (надо не забыть преобразовать `SALES.DATE` к типу данных `DATE` для правильности сортировки). 

В решении `SUM(PRICE::INT * QTY)` – суммы продаж для каждого магазина и категории по определенной дате. `LAG(SUM(PRICE::INT * QTY)) OVER w` – суммы продаж для каждого магазина и категории по предыдущей дате.

Результаты запроса для нашего удобства просмотра отсортированы по дате `DATE_`, магазину `SHOPNUMBER` и по товарному направлению `CATEGORY`. Для правильного сравнения в сортировке дата приведена к типу данных `DATE`.
