# wb-tech-school-hw1/SQL/sorting and grouping

Задания выполнялись с использованием PostgreSQL.

## Часть 1. Задание 1.
Я четко следовал условию: выполняю группировку по городу и по возрастной категории (ведь условии сказано “для каждого города” и “сгруппированных по возрастным категориям”). Также в условии сказано: “Для каждого города выведите число покупателей… отсортированных по убыванию количества покупателей в каждой категории.” - я это интерпретирую, как сортировку и по городу, и по убыванию кол-ва покупателей (иначе один и тот же город может неупорядоченно появляться в результирующей таблице - не будет соответствия количества покупателей каждому городу). 

P.S. Я привел в решении два запроса (на всякий случай, чтобы не было неоднозначностей): в одном группировка по возрасту человека, ведь “под возрастной категорией подразумевается возраст человека”; другой – “именно для категорий”, которые определяются оператором case.

## Часть 1. Задание 2.
Тут проще: просто следую условию, постепенно всё добавляю: сначала выбираю товары с названиями, соответствующими нашим шаблонам (ilike - регистронезависимо), далее выполняю группировку по категории, после выбираю нужные столбцы. Я преобразовал среднюю цену к типу данных numeric, т.к. при импорте csv файла столбец price получил тип данных real, а при округлении средней цены до двух знаков после запятой возникла ошибка (*function round(double precision, integer) does not exist*), которая была исправлена с помощью преобразования к numeric.

## Часть 2. Задание 1. 
В задании просят средний рейтинг категорий продавца, я его округлил до двух знаков, чтобы мы в результате не смотрели на много знаков после запятой. 

В условии немного неоднозначно прописаны “остальные”, но в процессе обсуждения в беседе мы пришли к выводу, что poor – отличные от rich по суммарной выручке, т.е. те, кто продает более одной категории, но чья суммарная выручка <= 50 000. Но возникает вопрос, что делать с не poor и не rich – раз просят выводить метку poor или rich, то тех, кто не попадает, под данные категории просто не будем выводить (также обсудили это в беседе). Итак, rich: > 1 категории и суммарная выручка > 50000; poor: > 1 категории и суммарная выручка <= 50000; ни poor, ни rich: <= 1 категории. 

По коду: в табличном выражении t (я его использую, чтобы код остался читаемым) я выполняю группировку по seller_id и получаю seller_id, total_categ, avg_rating, total_revenue, также я сразу отметаю категорию ‘Bedding’, которая согласно условию не должна учитываться в расчетах. Раз мы решили тех, кто ни rich, ни poor, не выводить, то я добавляю в where условие total_categ > 1. При использовании полей из табличного выражения я определяю согласно вышеуказанным замечаниям категорию rich или poor. И в конце делаю сортировку по seller_id.

Замечу также, что под фразами “продают более одной категории” или “количество категорий” я понимаю именно уникальные категории (с этой целью делаю distinct; в задании 2 и 3 использую аналогичное понимание понятия категория), потому что, как мне кажется, репрезентативно именно разнообразие категорий: например, если продавец продает категорию шины в двух вариациях, например, зимние и летние, то категория по сути же одна, просто товаров в этой категории два. По сути, уникальность категорий играет роль только во 1-м задании 2-й части (в 2 и 3 distinct не влияет на результат), но я всё равно оставляю distinct в 2 и 3 задании с расчётом на то, что данные могут поменяться  (например, нам принесут обновленные данные и там уже будут продавцы, которые будут включаться / не включаться в результат из-за уникальности / неуникальности).

## Часть 2. Задание 2.
Здесь не буду использовать табличное выражение для получения неуспешных продавцов (ведь нам не требуется делать case для получения двух меток (нужна только метка 'poor') и вычислять кучу столбцов). Таких продавцов определяю через условие having в группировке.

Также заметим, что у одного продавца может быть несколько категорий, значит, и несколько дат регистрации. Будем считать датой регистрации каждого продавца самую раннюю дату регистрации из имеющихся для каждого продавца (обсуждалось в беседе). Т.е. под продавцом я понимаю уникальный seller_id (соответственно группировка именно по нему). 

Вместо времени, когда выполняется задание так и хочется написать current_date, но все же раз нужно время выполнения, то будем использовать ‘2024-11-11’.

Под “разницей между максимальным и минимальным сроком доставки среди неуспешных продавцов” я понимаю максимум срока доставки среди всех неуспешных продавцов вычесть аналогичный минимум.

По коду: в табличном выражении t я получаю seller_id и min_date_reg для получения month_from_registration, но сразу здесь max_delivery_difference посчитать не можем (ведь мы работаем с группами), но можем посчитать максимум и минимум в каждой группе. Далее возьмем максимум из этих максимумов по группам и аналогично минимум из минимумов по группам, после считается искомое поле max_delivery_difference. 

Альтернативой данному решению может быть решение, где в еще одном табличном выражении вычисляется max_delivery_difference, но тогда потребуется подзапрос для проверки того, что seller_id относится к неуспешным продавцам (результат у двух решений одинаковый, я проверил). Остановимся на первом решении, дабы избежать еще одного табличного выражения и подзапроса; более того, полученное решение получилось очень даже читаемым.

## Часть 2. Задание 3.
В данном задании “Отберите продавцов, зарегистрированных в 2022 году” я интерпретирую, как только те записи продавцов, где год даты регистрации 2022 (учтем это в условии фильтрации where). Остальные условия с агрегатными функциями прописаны в having. Из интересного - использование агрегатной функции string_agg, которая помогает нам собрать пару категорий. В ней я прописываю distinct, т.к. под категорией я понимаю уникальную категорию, и соответственно при выводе с разделителем '-' нас интересует именно пара уникальных категорий (иначе, например, если для продавца подходящего под условие есть записи с category “Game”, “Game”, “Fitness”, то результат был бы “Game - Game - Fitness”, в нашем же случае надо “Game - Fitness”).
